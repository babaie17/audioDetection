<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cloud Speech Test (minimal)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b1020; --card:#141a2e; --accent:#7aa2ff; --text:#e8ecff; --muted:#a6b0d6; }
    html,body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Helvetica Neue", sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 760px; margin: 40px auto; padding: 24px; background:var(--card); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    h1 { margin:0 0 16px; font-size: 22px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    select, button { background:#1b2340; color:var(--text); border:1px solid #2a3766; border-radius: 10px; padding:10px 12px; font-size:15px; }
    select:focus, button:focus { outline: 2px solid var(--accent); outline-offset: 2px; }
    button.mic { font-weight:600; border-radius: 999px; padding:14px 18px; display:inline-flex; align-items:center; gap:10px; }
    button.mic.recording { background: #b42334; border-color: #ff8a9b; }
    .status { margin-top: 14px; color: var(--muted); min-height: 1.4em; }
    .results { margin-top: 16px; background:#0f1630; border:1px solid #29376b; border-radius: 12px; padding: 12px; }
    .results h3 { margin: 0 0 8px; font-size:15px; color: var(--muted); }
    .list { display:flex; flex-direction:column; gap:8px; }
    .item { background:#121a38; border:1px solid #2a3766; border-radius: 10px; padding:10px 12px; }
    .tone { margin-top:8px; opacity:.7; font-size:12px; }
    .chips { display:flex; flex-wrap:wrap; gap:8px; }
    .chip { padding:6px 9px; border:1px solid #2a3766; border-radius:8px; background:#101735; }
    .pill { background:#0c1330; border:1px solid #26407a; padding:7px 10px; border-radius:999px; color:var(--muted); font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Cloud Speech Test (minimal)</h1>

    <div class="row">
      <label for="lang">Language:</label>
      <select id="lang">
        <option value="en-US" selected>English (United States)</option>
        <option value="zh-CN">中文（普通话，中国）</option>
        <option value="zh-TW">中文（國語，台灣）</option>
        <option value="ja-JP">日本語</option>
        <option value="ko-KR">한국어</option>
        <option value="es-ES">Español (España)</option>
      </select>

      <span class="pill">
        Provider:
        <select id="provider" style="background:transparent;border:none;color:var(--text);">
          <option value="azure" selected>Azure (Top-5)</option>
          <option value="openai">OpenAI (1-best)</option>
        </select>
      </span>
    </div>

    <div class="status" id="status">Idle.</div>

    <div class="results" id="results" hidden>
      <h3>Most probable results</h3>
      <div class="list" id="list"></div>
    </div>

    <div style="margin-top:16px;">
      <button id="micBtn" class="mic" type="button" aria-pressed="false">
        🎙️ <span id="micLabel">Start Recording</span>
      </button>
      <span class="pill" id="provInfo">Using: AZURE</span>
    </div>
  </div>

  <!-- Loader with homophone + tone helpers -->
  <script src="/js/pinyin-loader.js"></script>

  <script>
    const langSel = document.getElementById('lang');
    const providerSel = document.getElementById('provider');
    const statusEl = document.getElementById('status');
    const micBtn = document.getElementById('micBtn');
    const micLabel = document.getElementById('micLabel');
    const provInfo = document.getElementById('provInfo');
    const resultsBox = document.getElementById('results');
    const listEl = document.getElementById('list');

    let mediaRecorder = null;
    let chunks = [];
    let recording = false;

    function setStatus(msg, isError=false) {
      statusEl.textContent = msg;
      statusEl.style.color = isError ? '#ff9aa4' : 'var(--muted)';
    }
    function setRecording(on) {
      recording = on;
      micBtn.classList.toggle('recording', on);
      micBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
      micLabel.textContent = on ? 'Stop Recording' : 'Start Recording';
      provInfo.textContent = `Using: ${providerSel.value.toUpperCase()}`;
    }

    function renderCandidates(arr) {
      const items = (Array.isArray(arr) ? arr : []).filter(Boolean);
      resultsBox.hidden = false;
      listEl.innerHTML = '';
      if (items.length === 0) {
        const div = document.createElement('div');
        div.className = 'item';
        div.textContent = 'No speech recognized.';
        listEl.appendChild(div);
        return;
      }
      items.forEach((t, i) => {
        const div = document.createElement('div');
        div.className = 'item';
        div.textContent = `${i+1}. ${t}`;
        listEl.appendChild(div);
      });
    }

    function renderHomophones(zh) {
      if (!zh || !Array.isArray(zh.homophones) || zh.homophones.length === 0) return;
      const box = document.createElement('div');
      box.className = 'item';

      const head = document.createElement('div');
      head.style.marginBottom = '6px';
      head.style.opacity = '.85';
      head.textContent = zh.mode === 'singleChar'
        ? `Homophones for ${zh.input}${zh.bases?.length?` [${zh.bases.join(', ')}]`:''}:`
        : `Characters for "${zh.input}"${zh.bases?.length?` [${zh.bases.join(', ')}]`:''}:`;
      box.appendChild(head);

      const chips = document.createElement('div');
      chips.className = 'chips';
      zh.homophones.slice(0, 64).forEach(ch => {
        const span = document.createElement('span');
        span.className = 'chip';
        span.textContent = ch;
        chips.appendChild(span);
      });
      box.appendChild(chips);

      if (zh.toneLabel) {
        const tone = document.createElement('div');
        tone.className = 'tone';
        tone.textContent = `Detected tone: ${zh.toneLabel}`;
        box.appendChild(tone);
      }
      listEl.appendChild(box);
    }

    async function startRecording() {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      chunks = [];
  
      // Pick container by provider for best Azure compatibility
      const provider = (providerSel.value || '').toLowerCase();
      let mime = '';
  
      if (provider === 'azure') {
        // Azure: prefer WebM/Opus (widest acceptance across regions)
        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          mime = 'audio/webm;codecs=opus';
        } else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
          // fallback if WebM isn't available (rare)
          mime = 'audio/ogg;codecs=opus';
        } else {
          mime = ''; // let browser choose
        }
      } else {
        // OpenAI: either works, prefer WebM for consistency
        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          mime = 'audio/webm;codecs=opus';
        } else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
          mime = 'audio/ogg;codecs=opus';
        } else {
          mime = '';
        }
      }
  
      mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);
      chunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      mediaRecorder.onstart = () => setStatus('Listening…');
      mediaRecorder.start();
    }

    function stopRecording() {
      return new Promise(resolve => {
        if (!mediaRecorder) return resolve(null);
        mediaRecorder.onstop = () => {
          const type = chunks[0]?.type || 'application/octet-stream';
          const blob = new Blob(chunks, { type });
          resolve(blob);
        };
        mediaRecorder.stop();
      });
    }

    async function sendToServer(audioBlob) {
      const form = new FormData();
      form.append('audio', audioBlob, audioBlob.type.includes('wav') ? 'speech.wav' : 'clip.ogg');
      form.append('language', langSel.value);
      form.append('provider', providerSel.value);
      const r = await fetch('/api/transcribe', { method: 'POST', body: form });
      const ct = r.headers.get('content-type') || '';
      if (!ct.includes('application/json')) throw new Error(await r.text() || `HTTP ${r.status}`);
      const data = await r.json();
      if (!r.ok) throw new Error(typeof data.error === 'string' ? data.error : JSON.stringify(data));
      return data;
    }

    // tiny detectors for fallback
    const isSingleHan = s => [...(s||'')].filter(ch => /\p{Script=Han}/u.test(ch)).length === 1;
    const normalizePinyinKey = (s) => {
      const toneMap = {'ā':'a1','á':'a2','ǎ':'a3','à':'a4','ē':'e1','é':'e2','ě':'e3','è':'e4','ī':'i1','í':'i2','ǐ':'i3','ì':'i4','ō':'o1','ó':'o2','ǒ':'o3','ò':'o4','ū':'u1','ú':'u2','ǔ':'u3','ù':'u4','ǖ':'v1','ǘ':'v2','ǚ':'v3','ǜ':'v4','ü':'v'};
      let t = (s||'').trim().toLowerCase();
      if (!t || t.includes(' ')) return null;
      t = t.replace(/[āáǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜü]/g, m=>toneMap[m]||m);
      if (!/^[a-z]+[1-5]?$/.test(t) || t.length > 6) return null;
      return t;
    };

    micBtn.addEventListener('click', async () => {
      try {
        if (!recording) {
          await startRecording();
          setRecording(true);
        } else {
          setStatus('Processing…');
          const blob = await stopRecording();
          setRecording(false);
          if (!blob) { setStatus('No audio captured.', true); return; }

          const data = await sendToServer(blob);
          const candidates = Array.isArray(data.candidates) ? data.candidates : [];
          renderCandidates(candidates);

          // Render server homophones if present and non-empty
          let rendered = false;
          if (data.zhAugment && Array.isArray(data.zhAugment.homophones) && data.zhAugment.homophones.length > 0) {
            renderHomophones(data.zhAugment);
            rendered = true;
          }

          // Minimal client fallback (only when Chinese selected and server gave none)
          const langPrimary = (langSel.value||'').split('-')[0];
          const top = (candidates[0] || '').trim();
          if (!rendered && langPrimary === 'zh' && top && window.pinyinLoader) {
            // strip punctuation like "。"
            const onlyHan = [...top].filter(ch => /\p{Script=Han}/u.test(ch)).join('');
            if (onlyHan && onlyHan.length === 1 && window.pinyinLoader.homophonesFromHanziWithTone) {
              const { homophones, toneLabel } = await window.pinyinLoader.homophonesFromHanziWithTone(onlyHan);
              if (homophones && homophones.length) renderHomophones({ mode:'singleChar', input: onlyHan, bases: null, homophones, toneLabel });
            } else if (window.pinyinLoader.homophonesFromPinyinWithTone) {
              const key = normalizePinyinKey(top);
              if (key) {
                const { homophones, toneLabel } = await window.pinyinLoader.homophonesFromPinyinWithTone(key);
                if (homophones && homophones.length) renderHomophones({ mode:'singlePinyin', input: top, bases: [key.replace(/[1-5]$/,'')], homophones, toneLabel });
              }
            }
          }

          setStatus(`Done. Received ${candidates.length} result(s).`);
        }
      } catch (err) {
        console.error(err);
        setRecording(false);
        setStatus(err.message || 'Error', true);
      }
    });
  </script>
</body>
</html>
